#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Pending Features:
  - PSI Indicator in title?  PSI Page (maybe with a thread)?
  - Default is window mode
  - Help Menu
  - Real-time controls:
    - others (i.e., brief) 
    - units
    - page up/down
    - fit window
  - CPU of processes and overall?
  - Ability to kill processes?



Copyright (c) 2022 Joe Defen

A program to aggregate the memory used by processes into categories
so that the memory footprint of processes is more clear.

The lines of smaps look as sequences of the lines shown
below. We call the 1st line a "section line" and those following "item lines".

    00400000-004b8000 r-xp 00000000 fd:00 11143998     /opt/.../inetrep
    Size:                736 kB
    Rss:                 592 kB
    Pss:                  87 kB
    Shared_Clean:        592 kB
    Shared_Dirty:          0 kB
    Private_Clean:         0 kB
    Referenced:          592 kB
    Anonymous:             0 kB
    AnonHugePages:         0 kB
    Swap:                  0 kB
    KernelPageSize:        4 kB
    MMUPageSize:           4 kB

NOTE: kB is a misnomer ... should be "KB".  Morons.
"""
# pylint: disable=broad-except,import-outside-toplevel,global-statement
# pylint: disable=too-many-boolean-expressions,invalid-name
# pylint: disable=too-many-instance-attributes

import os
import re
import sys
import atexit
import traceback
import time
import curses
# from curses.textpad import rectangle
from types import SimpleNamespace
from io import StringIO
from datetime import datetime, timedelta


# Trace Levels:
#  0 - forced, temporary debugging (comment it out)
#  1+ - regular debugging (higher is less important and/or more verbose)

DebugLevel = 0

def DB(level, *opts, **kwargs):
    """Debug message printer.
    - printing is conditional on DebugLevel being no smaller than the passed level
    - level 0 is unconditional. It is use for temporary traces that
      are commented out when the debug need is gone.
    """
    # pylint: disable=protected-access
    # print(f'DbLevel={DebugLevel} level={level} do_debug={bool(DebugLevel>=level)}')
    if DebugLevel >= level:
        lineno = sys._getframe(1).f_lineno
        tstr = StringIO()
        print(f'DB{level}', end=' ', file=tstr)
        kwargs['end'] = ' '
        kwargs['file'] = tstr
        print(*opts, **kwargs)
        print(tstr.getvalue() + f'[:{lineno}]')

##############################################################################
##   human()
##############################################################################
def human(number):
    """ Return a concise number description."""
    suffixes = ['K', 'M', 'G', 'T']
    while suffixes:
        suffix = suffixes.pop(0)
        number /= 1024
        if number < 999.95 or not suffixes:
            return f'{number:.1f}{suffix}'

######
####################################################################################
######

class Window:
    """ Layer above curses to encapsulate what we need """
    timeout_ms = 200
    static_scr = None
    """TBD"""
    def __init__(self, head_line=True, head_rows=10, body_rows=200, body_cols=200):
        self.scr = self._start_curses()
        self.head_rows = head_rows
        self.body_rows, self.body_cols = body_rows, body_cols
        self.head = curses.newpad(head_rows, body_cols)
        self.body = curses.newpad(body_rows, body_cols)
        self.head_count = 0
        self.head_lines = 1 if head_line else 0
        self.body_count = 0
        self.scroll_pos = 0  # how far down into body are we?
        self.rows, self.cols = 0, 0
        self.max_body_count, self.max_scroll = 0, 0
        self._set_screen_dims()
        self.calc()

    def _set_screen_dims(self):
        """Recalculate dimensions ... return True if geometry changed."""
        rows, cols = self.scr.getmaxyx()
        same = bool(rows == self.rows and cols == self.cols)
        self.rows, self.cols = rows, cols
        return same

    @staticmethod
    def _start_curses():
        """ Curses initial setup.  Note: not using curses.wrapper because we
        don't wish to change the colors. """
        atexit.register(Window.stop_curses)
        Window.static_scr = scr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        scr.keypad(1)
        scr.timeout(Window.timeout_ms)
        scr.clear()
        return scr

    @staticmethod
    def stop_curses():
        """ Curses shutdown (registered to be called on exit). """
        if Window.static_scr:
            curses.nocbreak()
            curses.echo()
            Window.static_scr.keypad(0)
            curses.endwin()
            Window.static_scr = None

    def calc(self):
        """Recalculate dimensions ... return True if geometry changed."""
        same = self._set_screen_dims()
        self.head_count = min(self.rows - self.head_lines, self.head_count)
        self.max_body_count = self.rows - self.head_count - self.head_lines
        self.max_scroll = max(self.body_count - self.max_body_count, 0)
        self.body_base = self.head_count + self.head_lines
        return not same

    def add_header(self, text, attr):
        """Add text to header"""
        if self.head_count < self.head_rows:
            if attr:
                self.head.addstr(self.head_count, 0, text, attr)
            else:
                self.head.addstr(self.head_count, 0, text)
            self.head_count += 1

    def add_body(self, text, attr=None):
        """ Add text to body (below header and header line)"""
        if self.body_count < self.body_rows:
            if attr:
                self.body.addstr(self.body_count, 0, text, attr)
            else:
                self.body.addstr(self.body_count, 0, text)
            self.body_count += 1

    def _scroll_indicator_row(self):
        """ Compute the absolute scroll indicator row:
        - We want the top to be only when scroll_pos==0
        - We want the bottom to be only when scroll_pos=max_scroll-1
        """
        if self.max_scroll <= 1:
            return self.body_base
        y2, y1 = self.max_body_count-1, 1
        x2, x1 = self.max_scroll, 1
        x = self.scroll_pos
        pos = y1 + (y2-y1)*(x-x1)/(x2-x1)
        return min(self.body_base + int(max(pos, 0)), self.rows-1)

    def render(self):
        """Draw everything added."""
        self.calc()
        if self.max_scroll <= 0:
            self.scr.refresh()
        if self.head_count < self.rows:
            # rectangle(self.scr, self.head_count, 0, self.head_count, self.cols-1)
            self.scr.hline(self.head_count, 0, curses.ACS_HLINE, self.cols)
        if self.max_scroll > 0:
            # rectangle(self.scr, self.body_base, 0, self.rows-1, 0)
            self.scr.vline(self.body_base, 0, curses.ACS_VLINE, self.max_body_count)
            self.scr.addstr(self._scroll_indicator_row(), 0, '|', curses.A_REVERSE)
            self.scr.attron(curses.A_REVERSE)
            # self.scr.vline(self._scroll_indicator_row(), 0, curses.ACS_VLINE, 1)
            self.scr.attroff(curses.A_REVERSE)
            self.scr.refresh()

        if self.rows > 0:
            self.head.refresh(0, 0, 0, 1 if self.max_scroll > 0 else 0,
                      min(self.head_count, self.rows)-1, self.cols-1)
        if self.body_base < self.rows:
            self.scroll_pos = max(self.scroll_pos, 0)
            self.scroll_pos = min(self.scroll_pos, self.max_scroll)
            self.body.refresh(self.scroll_pos, 0,
                  self.body_base, 1 if self.max_scroll > 0 else 0,
                  self.rows-1, self.cols-1)

    def clear(self):
        """Clear in prep for new screen"""
        self.scr.clear()
        self.head.clear()
        self.body.clear()
        self.head_count = self.body_count = 0

    def prompt(self, seconds=1.0):
        """Here is where we sleep waiting for commands or timeout"""
        elapsed = 0.0
        while elapsed < seconds:
            key = self.scr.getch()
            if key == curses.ERR:
                elapsed += self.timeout_ms / 1000
                continue
            if key in (curses.KEY_RESIZE, ) or curses.is_term_resized(self.rows, self.cols):
                # self.scr.erase()
                self._set_screen_dims()
                self.render()
                
            if key in (ord('k'), curses.KEY_UP):
                self.scroll_pos = max(self.scroll_pos - 1, 0)
                self.render()
            elif key in (ord('j'), curses.KEY_DOWN):
                self.scroll_pos += 1
                self.render()
            else:
                pass # unknown key


######
####################################################################################
######

class ProcMem:
    """Represents the memory map summation for processes and groups.
      - the ProcMem object represents one process (or pid)
      - the ProcMem static data represents aggregate data for groups.
    """
    # pylint: disable=too-many-instance-attributes
    section_pat = re.compile(
            r'^([0-9a-f]+)-([0-9a-f]+)' # $1,$2: 00400000-004b8000
            + r'\s+([a-z-]+)'   # $3: r-xp
            + r'\s+([0-9a-f]+)'  # $4: 00000000
            + r'\s+(\S+)'  # $5: fd:00
            + r'\s+(\d+)'  # $6: 11143998
            + r'(\s*|\s+(\S.*))$' # $8: /.../inetrep
            , re.IGNORECASE)
    item_pat = re.compile(
            r'^(\w+):' # $1: MMUPageSize:
            + r'\s+(\d+)'  # $2: 4
            + r'\s+kb$'  # kB
            , re.IGNORECASE)
    junk_pat = re.compile(
            r'^(THPeligible|VmFlags)'
            , re.IGNORECASE)
    opts = None
    # debug = 0
    # summaries = {} # indexed by pid TODO remove this (replace by groups)
    # prcs = {}
    # groups = {} # indexed by group key (e.g., cmd)
    # divisor = 0 # determined by arguments
    # units = '' # determined by arguments
    # fwidth = 11
    pmemstat = None # the main program object
    max_cmd_len = 32 # command line maximum length
    chunk_dict = {
            'cat': None,
            'beg': 0,
            'end': 0,
            'offset': 0,
            'size': 0,
            'eSize': 0,
            'rss': 0,
            'pss': 0,
            'shared': 0,
            'private': 0,
            'swap': 0,
            'pswap': 0,
            'perms': '',
            'item': '',
            }

    def __init__(self, pid):
        self.pid = pid
        self.alive = True
        self.is_new = True
        self.wanted = True # until proven otherwise
        self.is_changed = False
        self.whynot = None # populate me with why unwanted
        self.smaps_file = f'/proc/{self.pid}/smaps'
        self.rollup_file = f'/proc/{self.pid}/smaps_rollup'
        self.rollup_lines = None
        self.smaps_lines = None
        self.chunks = []

        self.exebasename = None, None
        self.key, self.cmdline, self.cmdline_trunc = None, None, None


    def get_cmdline(self):
        """Get the command line of the PID."""
        try:

            cmdline_file = f'/proc/{self.pid}/cmdline'
            try:
                # pylint: disable=consider-using-with
                line = open(cmdline_file, encoding='utf-8').read()[:-1]
            except FileNotFoundError as exc:
                # this seems to be a race which ignore; either the process is just
                # started or just quickly ended before even identified
                if DebugLevel:
                    DB(1, f'skip pid={self.pid} no-rollup-lines exc={type(exc).__name__}')
                return
            arguments = line.split('\0')
            if not arguments or not arguments[0]: # kernel process
                self.wanted = False
                self.whynot = 'KernelProcess'
                # print(f'{self.pid}: kernel thread')
                return
            # DB(0, f'{self.pid}: {arguments}')
            # sometimes the first word
            wds = os.path.basename(arguments[0]).split() + arguments[1:]
            basename = re.sub(r'^\W+', '', wds.pop(0))
            basename = re.sub(r'\W+$', '', basename)
            # DB(0, f'basename={basename} wds={wds}')
            if basename in ('python', 'python2', 'python3', 'perl', 'bash', 'ruby',
                    'sh', 'ksh', 'zsh') and wds:
                script = os.path.basename(wds[0])
                # DB(0, f'script={script} wds[0]={wds[0]}')
                if script != wds[0]:
                    basename = f'{basename}->{script}'
                    del wds[0]
            self.exebasename = basename
            self.cmdline = ' '.join([basename] + wds)
            self.cmdline_trunc = self.cmdline[0:ProcMem.max_cmd_len]
            # DB(0, f'basename={basename} cmdline_trunc={self.cmdline}')
        except Exception as exc:
            # not really expecting this ... probably a bug
            print(f'  WARNING: skip pid={self.pid} no-basename exc={exc}')
            print(traceback.format_exc())
            self.wanted = False
            self.whynot = 'CannotGetCmdline'
            return

        ## print(f'DBDB: {self.pid} {ProcMem.opts.pids}')
        # filter unwanted before too much work
        if (ProcMem.opts.pids and str(self.pid) not in ProcMem.opts.pids
                and self.exebasename not in ProcMem.opts.pids):
            self.wanted = False
            self.whynot = 'FilteredByArgs'
            # print(f'    >>>> unwanted {pid}')
        ## print(f'DBDB: {self.pid} wanted={self.wanted} whynot={self.whynot}')
        self.key = (self.cmdline_trunc if ProcMem.opts.groupby == 'cmd' else
                self.exebasename if ProcMem.opts.groupby == 'exe' else self.pid)

    def read_lines(self, filename):
        """ Get the lines of the smaps """
        lines = None
        try:
            with open(filename, encoding='utf-8') as fhandle:
                lines = fhandle.read().splitlines()
        except (PermissionError, FileNotFoundError) as exc:
            # normal cases: not permitted or this is a race where the pid is terminating
            self.whynot = f'CannotReadLines({type(exc).__name__})'
        except Exception as exc:
            # unexpected cases (probably a bug)
            print(f'ERROR: skip pid={self.pid} no-smaps-or-rollup-lines exc={type(exc).__name__}')
            self.whynot = f'CannotReadLines({type(exc).__name__})'
        return lines

    def get_rollup_lines(self):
        """Get the lines of the 'smaps_rollup' file for this PID"""
        try:
            self.rollup_lines = self.read_lines(self.rollup_file)
        except Exception as exc:
            self.rollup_lines = None
            if DebugLevel:
                DB(1, f'skip pid={self.pid} no-rollup-lines exc={type(exc).__name__}')

        if not self.rollup_lines:
            self.wanted = False
            self.whynot = 'CannotReadRollups'
        elif DebugLevel:
            DB(3, f'pid={self.pid} {self.exebasename} #rollup_lines={len(self.rollup_lines)}')

        return bool(self.rollup_lines)

    def get_smaps_lines(self):
        """Get the lines of the 'smaps' file for this PID"""
        try:
            self.smaps_lines = self.read_lines(self.smaps_file)
        except Exception as exc:
            self.smaps_lines = None
            if DebugLevel:
                DB(1, f'skip pid={self.pid} no-smap-lines exc={type(exc).__name__}')

        if not self.smaps_lines:
            self.wanted = False
            self.whynot = 'CannotReadSmaps'
        else:
            if DebugLevel:
                DB(1, f'pid={self.pid} {self.exebasename} #smaps_lines={len(self.smaps_lines)}')
        return bool(self.smaps_lines)

    def make_chunks(self, lines):
        """ Parse the already smaps read lines."""
        chunk = None
        for idx, line in enumerate(lines):
            match = self.section_pat.match(line)
            if match:
                if chunk:
                    self.chunks.append(chunk)
                chunk = SimpleNamespace(**ProcMem.chunk_dict)
                chunk.beg = int(match.group(1), 16)
                chunk.end = int(match.group(2), 16)
                chunk.perms = match.group(3)
                chunk.offset = int(match.group(4), 16)
                chunk.item = match.group(8)
                continue
            match = self.item_pat.match(line)
            if match:
                tag = match.group(1)
                val = int(match.group(2))
                if tag == 'Size':
                    chunk.size = val
                elif tag == 'Rss':
                    chunk.rss = val
                elif tag.startswith('Shared'):
                    chunk.shared += val
                elif tag.startswith('Private'):
                    chunk.private += val
                elif tag == 'Swap':
                    chunk.swap = val
                elif tag == 'Pss':
                    chunk.pss = val
                continue
            match = self.junk_pat.match(line)
            if match:
                continue
            print(f'ERROR: cannot parse "{line}" [{self.smaps_file}:{idx+1}]')
        if chunk:
            self.chunks.append(chunk)

    @staticmethod
    def make_summary_dict(pid=0, info=''):
        """ Make an object to summarize memory use of a PID or group """
        summary = {
                'pswap': 0,
                'shSYSV': 0,
                'shOth': 0, # e.g., memory mapped file
                'stack': 0,
                'text': 0,
                'data': 0, # deprecated 'pseudo' (e.g., memory barrier) now in 'data'
                'ptotal': 0,
                'pss': 0,  # comes from rollups
                'number': -pid if pid else 0, # count if positive; else -pid
                'info': info,
                }
        return summary

    def parse_rollups(self, lines):
        """ Parse the already read lines."""
        summary = ProcMem.make_summary_dict()
        for idx, line in enumerate(lines):
            if not line.endswith('kB'):
                continue
            match = self.item_pat.match(line)
            if match:
                tag = match.group(1)
                val = int(match.group(2))
                if tag == 'Pss_Anon':
                    summary['data'] += val
                    summary['ptotal'] += val
                elif tag == 'Pss_File':
                    summary['text'] += val
                    summary['ptotal'] += val
                elif tag == 'Pss_Shmem':
                    summary['shOth'] += val
                    summary['ptotal'] += val
                elif tag == 'SwapPss':
                    summary['pswap'] += val
                continue
            print(f'ERROR: cannot parse "{line}" [{self.rollup_file}:{idx+1}]')
        summary['pss'] = summary['ptotal'] # for consistency
        return summary

    def categorize_chunks(self):
        """ Analyze the chunks to categorize the memory """
        for idx, chunk in enumerate(self.chunks):
            chunk.eSize = chunk.size
            if chunk.cat: # if already done, don't do again
                continue

            if 's' in chunk.perms:
                if 'SYSV' in chunk.item:
                    chunk.cat = 'shSYSV'
                    # chunk.eSize = chunk.rss + chunk.swap
                    chunk.eSize = chunk.pss
                else:
                    chunk.cat = 'shOth'
                    chunk.eSize = chunk.pss
            elif chunk.item and '[stack]' in chunk.item:
                chunk.cat = 'stack'
                chunk.eSize = chunk.private
            elif (chunk.size == 4 and idx < len(self.chunks) - 1
                    and chunk.offset == chunk.beg and not chunk.item
                    and '---p' in chunk.perms):
                    # stack seems to be 4K unwriteable immediately followed
                    # by something very huge like 10240 or 10236.
                    # The size is bogus ... replace the 'Size' with
                    # the 'Private' plus swapped
                nchunk = self.chunks[idx+1]
                if (chunk.end == nchunk.end
                        and 'w' in nchunk.perms
                        and not nchunk.item
                        and nchunk.offset == nchunk.beg
                        and nchunk.size >= 10000
                        and nchunk.size <= 20000):
                    chunk.eSize = 0
                    chunk.cat = 'data' # was 'pseudo'
                    nchunk.eSize = nchunk.private + nchunk.swap
                    nchunk.cat = 'stack'
            if not chunk.cat:
                if '---' in chunk.perms:
                    chunk.cat = 'data' # was 'pseudo'
                    chunk.eSize = 0
                elif 'w' in chunk.perms:
                    chunk.cat = 'data'
                    chunk.eSize = chunk.rss + chunk.swap
                else:
                    chunk.cat = 'text'
                    chunk.eSize = chunk.pss + chunk.swap
        if DebugLevel:
            for chunk in self.chunks:
                DB(6, '{self.pid} {self.exebasename} CHUNK:', chunk)


    def summarize_chunks(self):
        """ Accumulate the chunks into the summary of memory use for the PID """
        summary = self.make_summary_dict(self.pid)

        for chunk in self.chunks:
            if DebugLevel:
                DB(5, f'{self.pid} {self.exebasename} BLK: {chunk.cat} eSize={chunk.eSize}'
                    + f' size={chunk.size} {chunk.perms} {chunk.item}')
            summary[chunk.cat] += chunk.eSize
            summary['ptotal'] += chunk.eSize
            summary['pswap'] += chunk.pswap
        # print(f'DB self.summaries[{key}]: {self.summaries[key]}')
        return summary

    def prc_pid(self):
        """Process one PID"""
        self.alive = True
        self.is_changed = False
        if not self.whynot and not self.cmdline:
            self.get_cmdline()
            if not self.cmdline:
                return
        if not self.whynot:
            self.get_rollup_lines()
        if self.whynot:
            DB(4, f'pid={self.pid} {self.exebasename} whynot={self.whynot}')
            return
        self.is_changed = False
        rollup_summary = self.parse_rollups(self.rollup_lines)
        group = self.pmemstat.get_group(self.key)
        if not group.alive:
            info = str(self.key)
            if ProcMem.opts.groupby == 'pid':
                info += ' ' + self.cmdline_trunc
            group.rollup_summary = ProcMem.make_summary_dict(info=info)
            group.summary = ProcMem.make_summary_dict(info=info)
            group.alive = True
        self.pmemstat.add_to_summary(rollup_summary, group.rollup_summary)
        group.prcset.add(self)

######
####################################################################################
######

class PmemStat:
    """ The singleton class for running the main loop, etc"""

    def __init__(self, opts):
        self.opts = opts
        self.debug = opts.debug
        self.units = opts.units
        self.prcs = {}
        self.groups = {} # indexed by group key (e.g., cmd)
        if self.units == 'mB':
            self.divisor = 1000*1000
            self.fwidth = 8
        elif self.units == 'MB':
            self.divisor = 1024*1024
            self.fwidth = 8
        elif self.units == 'KB':
            self.divisor = 1024 # KB (the original)
            self.fwidth = 11
        else: # human
            self.divisor = 1 # human
            self.fwidth = 7
        self.window = None

    def get_group(self, key):
        """Per group info."""
        group = self.groups.get(key, None)
        if not group:
            group = SimpleNamespace(key=key,
                    is_new=True,
                    alive=False,
                    whynot=None,
                    changed=False,
                    o_prcset=set(),
                    prcset=set(),
                    o_rollup_summary=None,
                    rollup_summary=None,
                    o_summary=None,
                    summary=None,
                    first_summary=None,
                    growth_pct=0.0)
            self.groups[key] = group
            # DB(0, f'add group[{key}]')
        return group

    def prep_new_loop(self):
        """Prepare for a new loop.
        Returns whether or not any groups are left.
        If not, it will be time to terminate.
        """
        if self.groups:
            for key in list(self.groups):
                group = self.groups[key]
                if not group.alive:
                    del self.groups[key]
                    # DB(0, f'del group[{key}]')
                    continue
                group.is_new = False
                group.alive = False
                group.o_rollup_summary, group.rollup_summary = group.rollup_summary, None
                if group.prcset:
                    group.o_prcset, group.prcset = group.prcset, set()
                group.is_changed = False
                group.delta_pss = 0

        for pid in list(self.prcs):
            prc = self.prcs[pid]
            if not prc.alive:
                del self.prcs[pid]
                continue
            prc.alive = False
            prc.rollup_lines = None
            prc.smaps_lines = None
            prc.chunks = []
        return self.groups

    @staticmethod
    def add_to_summary(summary, total):
        """ Add a summary memory use into a running total of memory use """
        if summary and total:
            for key, val in summary.items():
                if key in ('info',):
                    pass
                elif key in ('number',):
                    total[key] += 1 if val <= 0 else val
                elif isinstance(val, int):
                    total[key] += val


    def test_delta(self, group, summary, o_summary):
        """Check whether the group rollup or smaps summary exceeds threshold """
        # pylint: disable=chained-comparison
        is_over = False
        # DB(0, f'{group.key} o=[{group.o_summary}]\n          n=[{group.summary}]')
        delta_pss = summary['pss'] - o_summary['pss'] + summary['pswap'] - o_summary['pswap']
        thresh = self.opts.min_delta_kb

        # DB(0, f'{group.key} ~pss {delta_pss}KB min={self.opts.min_delta_kb}')
        # DB(0, f'{group.key} ~pss {delta_pss}KB thresh={thresh}')
        if ((thresh <= 0 and abs(delta_pss) >= -thresh)
                or (thresh > 0 and delta_pss >= thresh)):
            is_over = True
            if self.debug:
                DB(2, f'{group.key} ~pss {delta_pss}KB thresh={thresh}')
        return is_over, delta_pss

    def prc_group(self, group):
        """Process on group"""
        do_smaps = False
        if group.o_rollup_summary:
            do_smaps, _ = self.test_delta(
                    group, group.rollup_summary, group.o_rollup_summary)
        else:
            do_smaps = True

        for prc in list(group.prcset):
            group.summary['info'] = (f'{prc.exebasename}' if self.opts.groupby == 'exe'
                    else f'{prc.cmdline_trunc}' if self.opts.groupby == 'cmd'
                    else f'{prc.pid} {prc.cmdline_trunc}')
            if do_smaps:
                prc.get_smaps_lines()
                if prc.whynot:
                    group.prcset.remove(prc)
                    continue
                prc.make_chunks(prc.smaps_lines)
                prc.categorize_chunks()
                summary = prc.summarize_chunks()
                self.add_to_summary(summary, group.summary)
            prc.chunks, prc.smaps_lines, prc.rollup_lines = [], [], []
        group.summary['pss'] = group.rollup_summary['ptotal']
        group.summary['pswap'] = group.rollup_summary['pswap']

        if not group.prcset:
            group.alive = False
            do_smaps = False
        if not do_smaps:
            group.summary = group.o_summary
            return

        if self.debug:
            DB(2, f'{group.key} summary: {group.summary}')

        group.is_changed = False
        if group.o_summary:
            group.is_changed, group.delta_pss = self.test_delta(
                    group, group.summary, group.o_summary)
        else:
            group.is_changed = True

        if group.first_summary:
            group.growth_pct = 100*(group.summary['ptotal']
                - group.first_summary['ptotal'])/group.first_summary['ptotal']
        else:
            group.first_summary = group.summary

        if group.is_changed:
            group.o_summary = group.summary
        elif group.o_summary:
            group.summary = group.o_summary

        if self.debug:
            DB(1 if group.is_changed else 5, f'{group.key}:', group.summary)

    def pr_exclusions(self):
        """ TBD """
        exclusions = {'number', 'info'}
        others = ['text', 'shSYSV', 'shOth', 'stack'] if self.opts.others else []
        if not self.debug:
            exclusions.add('pss')
        return others, exclusions

    def pr_summary(self, lead, summary, attr=None, to_head=False):
        """Print a summary of memory use"""
        body = ''
        others, exclusions = self.pr_exclusions()
        others_mb = 0
        for item, value in summary.items():
            if item not in exclusions:
                mbytes = int(round(value*1024/self.divisor))
                if item in others:
                    others_mb += mbytes
                    if item != others[0]:
                        continue
                    mbytes = others_mb
                if self.divisor > 1:
                    body += f'{mbytes:>{self.fwidth},}'
                else:
                    body += f'{human(mbytes):>{self.fwidth}}'
        num = summary['number']
        self.emit(f'{body} {lead} '
                  + (f'{-num}' if num <= 0 else f'{num}x')
                  + ' ' + summary['info'], attr=attr, to_head=to_head)

    @staticmethod
    def get_meminfo():
        """Get most vital stats from /proc/meminfo'"""
        meminfofile = '/proc/meminfo'
        meminfoKB = {'MemTotal': 0, 'MemAvailable': 0, 'Dirty':0}
        keys = list(meminfoKB.keys())

        with open(meminfofile, encoding='utf-8') as fileh:
            for line in fileh:
                match = re.match(r'^([^:]+):\s+(\d+)\s*kB', line)
                if not match:
                    continue
                key, value = match.group(1), int(match.group(2))
                if key not in keys:
                    continue
                meminfoKB[key] = value
                keys.remove(key)
                if not keys:
                    break
        assert not keys, f'ALERT: cannot get vitals ({keys}) from {meminfofile}'
        return meminfoKB


    def loop(self, now, is_first):
        """one loop thru all pids"""
        # pylint: disable=too-many-branches
        total_pids = 0
        allpids = []
        wanted_prcs = {}
        meminfoKB = self.get_meminfo()

        with os.scandir('/proc') as it:
            for entry in it:
                # if re.match(r'^\d+$', entry.name):
                if entry.name.isdigit():
                    allpids.append(entry.name)

        for pid in allpids:
            ## print(f'DBDB pid={pid} self.opts.pids={opts.pids}')
            prc = self.prcs.get(pid, None)
            if not prc:
                prc = ProcMem(int(pid))
                self.prcs[pid] = prc
            else:
                prc.is_new = False
            prc.prc_pid()
            ## if str(pid) in opts.pids:
                ## print(f'DBDB pid={pid} dir={vars(prc)}')
            total_pids += 0 if prc.whynot == 'KernelProcess' else 1

            if prc.wanted:
                wanted_prcs[pid] = prc
                if self.debug:
                    DB(1, f'Doing pid={pid} exe={prc.exebasename} cmd={prc.cmdline_trunc}')
            else:
                if self.debug:
                    DB(4, f'Unwanted pid={pid} exe={prc.exebasename}')

        # all pids have been processed into groups.
        # for each group, if it has changed, sum all the smaps for the group
        # if the group rollup_summary indicates enough change
        grand_summary = ProcMem.make_summary_dict(info='---- GRAND TOTAL ----')
        for group in self.groups.values():
            if group.alive:
                self.prc_group(group)
                self.add_to_summary(group.summary, grand_summary)


        # print timestamp of report
        if not self.window:
            leader = f'\n---- {now.strftime("%H:%M:%S")}' 
        else:
            leader = f'{now.strftime("%H:%M:%S")}'
        leader += f' Mem={human(meminfoKB["MemTotal"]*1024)}'
        leader += f' Avail={human(meminfoKB["MemAvailable"]*1024)}'
        leader += f' Dirty={human(meminfoKB["Dirty"]*1024)}'
        leader += f' PIDs: {len(wanted_prcs)}/{total_pids}'
        self.emit(leader, to_head=True)

        # detect changed group on basis of differing PIDs contributing

        if grand_summary['number'] == 0:
            print('DONE: no pids to report ... exiting now')
            sys.exit(0)

        # print header and  grand totals
        header = ''
        others, exclusions = self.pr_exclusions()
        for item in grand_summary:
            if item not in exclusions:
                if item in others:
                    if item != others[0]:
                        continue
                    item = 'other'
                header += f'{item:>{self.fwidth}}'
        self.emit(f'{header}   key/info (in {self.units})', to_head=True,
                  attr=curses.A_BOLD)
        self.pr_summary('T', grand_summary, to_head=True)

        alive_groups = {}
        for key, group in self.groups.items():
            if group.alive:
                alive_groups[key] = group
                if not group.summary:
                    DB(0, 'no summary:', str(group))

        sorted_keys = sorted(alive_groups.keys(),
                key=lambda x: (alive_groups[x].is_changed,
                               alive_groups[x].summary['ptotal']), reverse=True)

        ptotal_limit = (grand_summary['ptotal'] * self.opts.top_pct / 100) * 1.001
        others_summary = None
        running_summary = ProcMem.make_summary_dict(info='---- RUNNING ----')
        for key in sorted_keys:
            group = alive_groups[key]
            self.add_to_summary(group.summary, running_summary)
            if running_summary['ptotal'] <= ptotal_limit:
                if group.alive and (group.is_new or group.is_changed or self.window):
                    attr = curses.A_REVERSE if group.is_new or group.is_changed else None
                    attr = None if is_first else attr
                    self.pr_summary('A' if group.is_new
                        else f'{group.delta_pss:+,}K' if group.is_changed
                        else ' ', group.summary, attr=attr)
                    # DB(0, f'obj: {vars(obj)}')
            elif is_first:
                if not others_summary:
                    others_summary = ProcMem.make_summary_dict(info='---- OTHERS ----')
                self.add_to_summary(group.summary, others_summary)
        if others_summary:
            self.pr_summary('O',  others_summary)


        for group in self.groups.values():
            if not group.alive and group.o_summary:
                self.pr_summary('x', group.o_summary)

        self.prep_new_loop()

    def emit(self, line, to_head=False, attr=None):
        """ Emit a line of the report"""
        if self.window:
            if to_head:
                self.window.add_header(line, attr)
            else:
                self.window.add_body(line, attr)
        else:
            print(line)

    def window_loop(self):
        """ TBD """
        self.window = Window(head_line=True)
        is_first = True
        for _ in range(1000000000):
            # self.window.add_header(f'title {loop}')
            # for i in range(40):
                # self.window.add_body(chr(0x61+(i%26)) * (self.window.body_cols-1))
            self.loop(datetime.now(), is_first)
            self.window.render()
            self.window.prompt(self.opts.loop_secs)
            self.window.clear()
            is_first = False

def main():
    """Main loop"""
    global DebugLevel
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-D', '--debug', action='count', default=0,
            help='debug mode (the more Ds, the higher the debug level)')
    parser.add_argument('-g', '--groupby', choices=('exe', 'cmd', 'pid'), default='exe',
            help='grouping method for presenting rows')
    parser.add_argument('-k', '--min-delta-kb', type=int, default=None,
            help='minimum percent KB to show again [dflt=100 if DB else 1000')
    parser.add_argument('-l', '--loop', type=int, default=0, dest='loop_secs',
            help='loop interval in seconds [dflt=0]')
    parser.add_argument('-L', '--cmdlen', type=int, default=36,
            help='max command line length for reporting/grouping  [dflt=36]')
    parser.add_argument('-t', '--top-pct', type=int, default=100,
            help='report group contributing to top pct of ptotal [dflt=100]')
    parser.add_argument('-o', '--others', action='store_true',
            help='collapse shSYSV, shOth, stack, text into "other"')
    parser.add_argument('-u', '--units', choices=('MB', 'mB', 'KB', 'human'), default='MB',
            help='units of memory [dflt=MB]')
    parser.add_argument('-w', '--window', action='store_true',
            help='show in "curses" window')
    parser.add_argument('pids', nargs='*', action='store',
            help='list of pids/groups (none means all we can read)')
    opts = parser.parse_args()
    # DB(0, f'opts={opts}')

    DebugLevel = opts.debug
    if opts.debug:
        DB(1, 'DebugLevel', DebugLevel)
    if opts.min_delta_kb is None:
        opts.min_delta_kb = 100 if opts.units == 'KB' else 1000
    if opts.window and opts.loop_secs < 1:
        opts.loop_secs = 5

    pmemstat = PmemStat(opts=opts)
    ProcMem.pmemstat = pmemstat
    ProcMem.opts = opts

    if opts.window:
        if opts.loop_secs <= 0:
            opts.loop_secs = 5
        pmemstat.window_loop()
    else:
        is_first = True
        while True:
            now = datetime.now()
            pmemstat.loop(now, is_first)
            if opts.loop_secs <= 0:
                break
            until_dt = now + timedelta(0, opts.loop_secs)
            diff_dt = until_dt - datetime.now()
            seconds = diff_dt.total_seconds()
            if seconds > 0:
                time.sleep(seconds)
            is_first = False


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as exce:
        Window.stop_curses()
        print("exception:", str(exce))
        print(traceback.format_exc())
